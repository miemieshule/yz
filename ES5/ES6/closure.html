<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> closure ES 闭包训练</title>
</head>
<body>

    <!-- <h2>万紫千红</h2>
    <button style="color:red" name="change-color">变红</button>
    <button style="color:blue" name="change-color">变蓝</button>
    <button style="color:yellow" name="change-color">变黄</button> -->
    
    <script>
        //  原生写法 
        // var btns = document.getElementsByTagName('button')

        // for (let i = 0; i  < btns.length ; i++) {
        //    btns[i].onclick = 
        //     function(){
        //         changeColor(this.style.color)
        //     }     
        // }

        // function changeColor(color) {
        //     document.getElementsByTagName('h2')[0].style.color = color;
        // }
        
    </script>



    <script>
        // return 返回写法 
        // var btns = document.getElementsByTagName('button')
        
        // for (let i = 0; i  < btns.length ; i++) {
        // btns[i].onclick = 
        //     // function(){
        //         changeColor(btns[i].style.color)
        //     // }     
        // }

        // function changeColor(color) {
        //     return function(){
        //         document.getElementsByTagName('h2')[0].style.color = color;
        //     }
           
        // }

        
        // 资料
        // change 改变 

        // 第一版是 
        // 点击事件调用， changeColor函数，完成值替换 
        // 一个点击执行，一个事件函数执行

        // 第二版
        // 点击事件调用，事件函数不执行 
        // 点击 只获取点击后的值，

        // changeColor函数调用外面的自己，所传的值 ， 或者说保存的值 
        // 值的作用域 

        // 不推荐写，太绕了，但是写的多啊 ，多打断点就看出来了 


        
    </script>

















        <!-- 行内绑定事件 -->
        <!-- <h2>万紫千红</h2> -->
        <!-- <button style="color:red" onclick="changeColor(this.style.color)"  name="change-color">变红</button>
        <button style="color:blue" onclick="changeColor(this.style.color)"   name="change-color">变蓝</button>
        <button style="color:yellow"  onclick="changeColor(this.style.color)"  name="change-color">变黄</button> -->

        <script>

        // function changeColor(color) {
        //         document.getElementsByTagName('h2')[0].style.color = color;
        // }

        </script>













        <!--面视题  -->
        <!-- 演示：当事件触发的时候，i 的值为3

        因为事件的绑定和触发是分离的：

        当事件绑定时，根本就没有使用到 i
        当事件触发时，for循环已经执行完毕，i 值为3（注意：i 是一个“全局”变量）
        -->
        <!-- <h2>万紫千红</h2> -->
        <!-- <button style="color:red" onclick="changeColor(this.style.color)"  name="change-color">变红</button>
        <button style="color:blue" onclick="changeColor(this.style.color)"   name="change-color">变蓝</button>
        <button style="color:yellow"  onclick="changeColor(this.style.color)"  name="change-color">变黄</button> -->

        <script>
        //     for (var i = 0; i < buttons.length; i++) {
        //     buttons[i].onclick = function () {
        //         document.getElementsByTagName('h2')[0].style.color = buttons[i].style.color;
        //     }
        // }
        </script>











        <!--IIFE 实现  -->
        <!-- 点击变色 大部分封进去  -->
        -->
        <!-- <h2>万紫千红</h2>
        <button style="color:red" onclick="changeColor(this.style.color)"  name="change-color">变红</button>
        <button style="color:blue" onclick="changeColor(this.style.color)"   name="change-color">变蓝</button>
        <button style="color:yellow"  onclick="changeColor(this.style.color)"  name="change-color">变黄</button> -->

        <script>
              var btns = document.getElementsByTagName('button')
            for (var i = 0; i < btns.length; i++) {        
           
            btns[i].onclick = (function (n) {                     //绑定时立即执行   //为了清晰，形参重命名为n
            
                    return function () {                   //立即执行之后返回的还是函数才行
                    document.getElementsByTagName('h2')[0].style.color = btns[n].style.color;
                    }

            })(i); //利用此时的i
        }

        </script>

        <script>
        // 信息量很大，同学们按这三步进行理解：

        // 利用IIFE，在事件绑定时就把 i 给“拽”进来
        // IIFE执行后必须返回一个“函数”给事件
        // （实参）i 传递给了 （形参）n

        //  for把 点击事件 和事件函数 返回中的n 都给人家绑好 
        // clik点击时候，敲开n的壳子，看里面放的啥，

        //  点子上：  以后会用 ，所以n会保留副本值 
        // 使用返回函数 n不会销毁 会被保存 ，for会1一步步变大，然后消失， 一次次绑定，一次次，保留i传给n的值 
        </script>









    <!-- 闭包简单讲解 -->
    <script>
        //     function luckyStack() {
        //     var _price = 986;

        //     return function () {
        //         return ++_price;
        //     }       //函数返回了一个函数
        // }

        // var getPrice = luckyStack();  //这个方法变形了  变成了 返回函数  typeof getPrice
        // console.log(getPrice); 
        
        // console.log(getPrice()); //  返回函数typeof getPrice 执行，拿到luckyStack()函数中局部变量  var _price = 986;的值 


        // alert(`"源栈"培训的价格是每周${getPrice()}元！`);   //看吧 通过变形函数 ，可以访问一个函数内部变量了 

        // 打印997
        // 弹窗998 
        // 这个值会一直保持，不会销毁的 

    </script>













    <!--let关键字 声明变量 实现 -->
    <!-- 怎么实现的 生命周期 -->
    
    <!-- <h2>万紫千红</h2>
    <button style="color:red" onclick="changeColor(this.style.color)"  name="change-color">变红</button>
    <button style="color:blue" onclick="changeColor(this.style.color)"   name="change-color">变蓝</button>
    <button style="color:yellow"  onclick="changeColor(this.style.color)"  name="change-color">变黄</button> -->

    <script>
    //      var btns = document.getElementsByTagName('button')
    //     for (let i = 0; i < btns.length; i++) {        
       
    //     btns[i].onclick = function () {                 
    //             document.getElementsByTagName('h2')[0].style.color = btns[i].style.color;
    //             }
    // }

    //    let在花括号里面起作用  块级作用域 
    // 在外面是全局，并且不占用window.name 
    // 这玩意，没有变量提升，在哪里声明，就在那一块的花括号用 

    // for的i是在函数内部的 作用 ，是封闭的，虽然展示在外面。
    // 副本理论说，我循环的时候，给了123，虽然我for i 花括号 销毁了，但是匿名函数形成的闭包引用i，不会消失 

    // 因为for的i声明周期变短会销毁，所有匿名函数function引用i的值，就会产生闭包效果，保存
    // i的一个副本，是长生命周期 
    
    </script>















    <!-- 作业 -->
    <!-- 
        在函数student()中声明了函数域变量name、age和female，使用闭包机制，将其暴露到函数外部
     -->

     <script>
        //     function student() {
        //     var student ={
        //        name :"派大星",
        //        age : 10,
        //     }

        //     return function () {
        //         return student;
        //     }  
        // }

        // var data = student();  

        // alert(`${data().name} ${data().age}！`); 
     </script>









    <!-- 作业 -->
    <!-- 
        解释以下代码运行结果：（ condition ? <statement when true> : <statement when false>）
     -->

    <script>
        //         function foo(x) {
        //     var tmp = 3;
        //     return function (y) {
        //         x = x ? x + 1 : 1;
        //         console.log(x + y + tmp);
        //     }
        // }

        // var bar = foo(-1);
        //或者：var bar = foo(1);
        //或者：var bar = foo(0);

        // bar(10);
    </script>






    <!-- 改动以下代码，让其输出如图所示，并说明理由。 -->

   <script>
            function buildList(list) {                      //buildList 构建列表   list列表 
            var result = [];                                 //result 结果 
            for (let i = 0; i < list.length; i++) {
                result.push(function () {
                    console.log('item' + i + ': ' + list[i])
                });
            }
            return result;
        }

        (function() {      //立即执行  
            var fnlist = buildList([1, 2, 3]);            //fn list 方法 list         // 根据长度执行三次 
            for (var i = 0; i < fnlist.length; i++) {
                fnlist[i]();
            }
        })();


        // 之前的疑惑
        // 为什么console不执行，还要放在那里

        // iife 
        // 立即执行函数中，先跑了一遍 存入函数 有数据可执行，用for给i添加，用let延长生命周期，0 1 2

        // 在第二层的for中，根据长度，再次执行函数存入函数，这时候就调用到了，console中的匿名函数执行部分
        // 你再看，取出的 1 2 3 ，是for循环取出的，

        // 在这里面，最有意思的是，立即执行有两层
        // 第一层直接执行函数 for 循环 i值 ， 得到 0 1 2 ，因为用到let不进行销毁，let销毁
        // 第二层，for循环 数组中值 ，得到 1 2 3 ，神奇的地方，后面执行的，但是没覆盖，前面的i值

        // ，这里的i能对应上，不同位置，仔细看 第二层for循环在执行什么

        // 最后两个i都保留了各自的位置，也延迟了周期 


        
        //输出如下
        // item0 ： 1
        // item1 ： 2
        // item2 ： 3

    </script>
















    <!-- 变量 可以改变 常量不可改变 -->
    <!-- 常量声明时候必须赋值 赋值后不可改 --> 
    <!-- 常量中的对象值可以改变 常量的是引用没有改变 但是对象的地址映射改变值 -->
    <script>
        const k = 1 ;
    </script>



</body>
</html>