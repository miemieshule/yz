<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <div id="propagate">
        <p>
            源栈欢迎您0
        </p>
    </div>

    <ul>

        <li id="li1">我是第1个li</li>
    
        <li id="li2">我是第2个li</li>
    
        <li id="li3">我是第3个li</li>
    
      </ul>


    <style>
        #propagate {
            padding: 30px;
            border: 1px solid;
        }

            #propagate > p {
                background-color: blue;
                border: 1px dashed;
            }
    </style>

    <!-- <script>
        var father = document.getElementById('propagate'),
            child = father.children[0];
        father.addEventListener('click', function () {
            console.log('event handler on father 父 ');
        });
        child.addEventListener('click', function () {
            console.log('event handler on child  子 ');
        });
    </script> -->

    <!-- 
        默认为冒泡触发顺序 
        点击子p标签 ，先触发子p标签，后触发父div
        点击父只触发父 div 
     -->

     <!-- <script>
        var father = document.getElementById('propagate'),
            child = father.children[0];
        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
        },true); 
        child.addEventListener('click', function () {
            console.log('event handler on child  子 p标签 ');
        },true);
    </script> -->
        <!-- 
        修改捕获为触发顺序 
        点击子 p标签 ，先触发父 div ，后触发子p
        点击父div 只触发父
     -->

     <!-- 
         捕获 一周渔网从当前位置往里勒着回收 抓到元素 , 先父元素 后子元素 
         //  事件捕获流的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件 
         冒泡一个泡泡越吹越大，泡泡范围内都是抓到的元素 先子元素后父元素 
      -->

        <!-- <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
            console.log(event.target);//返回哪个 DOM 元素触发了点击事件  // 返回结果 这个是父元素div ，我点击了p，返回了因为p触发了点击事件 
            console.log(event.currentTarget); //event.currentTarget则是事件绑定的元素 // 返回结果 这个是父元素div ，我点击了p，返回了因为是父元素绑定了点击事件 
        },true);  // 
        // 冒泡 


        child.addEventListener('click', function () {
            console.log('event handler on child  子 p标签 ');
            console.log(event.target); //返回哪个 DOM 元素触发了点击事件  // 返回结果 这个是p元素 ，我点击了p，返回了因为p触发了点击事件 
            console.log(event.currentTarget);  //event.currentTarget则是事件绑定的元素 // 返回结果 这个p标签绑定的 ，点击了p，返回p元素 
        },true);

        // bubble 冒泡 

    </script> -->

    <!-- <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
            console.log(event.target);//返回哪个 DOM 元素触发了点击事件  // 返回结果 这个是父元素div ，我点击了div，返回了因为div触发了点击事件 
            console.log(event.currentTarget); //event.currentTarget则是事件绑定的元素 // 返回结果 这个是父元素div ，我点击了div，返回了因为是父元素绑定了点击事件 
        },false);  // 这里设置的捕获，是从外面向里面捕获事件 顺序是div元素 - p元素 
        // 捕获 父元素点击后 不过两个div 


        child.addEventListener('click', function () {
            console.log('event handler on child  子 p标签 ');
            console.log(event.target); //返回哪个 DOM 元素触发了点击事件  // 返回结果 这个是p元素 ，我点击了p，返回了因为p触发了点击事件 
            console.log(event.currentTarget);  //event.currentTarget则是事件绑定的元素 // 返回结果 这个p标签绑定的 ，点击了p，返回p元素 
        },false);
        // 捕获 先执行子元素 未点击父元素 但是父元素点击事件执行了  -->

    <!-- </script> -->


    <!-- 阻断传播
    stopPropagation()
        需求 捕获事件流下，不允许子元素被抓进来执行事件  
    -->
        <!-- <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
            event.stopPropagation() // 父元素设置阻断 子元素执行事件不触发
        },true);  // 这里设置的捕获，是从外面向里面捕获事件 顺序是div元素 - p元素 
        // 捕获 


        child.addEventListener('click', function () {
            console.log('event handler on child  子 p标签 ');
        },true);
        // 捕获 

    </script> -->

    <!-- 说明
    捕获事件流下 隔断在最里面没有效果的 ，你要造墙肯定放外面造 才能拦住捕获路线 
    -->




        <!-- 阻断传播
    stopPropagation()
        需求 冒泡事件流下，不允许父元素被抓进来执行事件  
    -->
    <!-- <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
        },false);  
        // 冒泡 


        child.addEventListener('click', function () {
            event.stopPropagation()
            console.log('event handler on child  子 p标签 ');
        },false);
        // 冒泡 

    </script> -->

    <!-- 说明
    冒泡事件流下 隔断在最里面有效果 ，能关住要往外跑的冒泡路线 
    -->








            <!-- 阻断传播
    stopPropagation()
        需求 双事件流下，后一个冒泡事件流能挡住捕获事件流的路线吗？  在冒泡事件流设置阻断，造墙，能阻断吗？
        // 不会 
        // 放在捕获本身进攻路线上才能拦住 
    -->
    <!-- <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            console.log('event handler on father 父  div ');
        },true);  
        // 捕获


        child.addEventListener('click', function () {
            event.stopPropagation()
            console.log('event handler on child  子 p标签 ');
        },false);
        // 冒泡 
        // 不会阻断 因为执行顺序先的捕获会先到。
    </script> -->






                <!-- 阻断传播
    stopPropagation()
        需求 双事件流下，前冒泡事件流 后捕获事件流 能挡住捕获事件流的路线吗？  在第一个冒泡事件流 父元素 设置阻断，造墙，能阻断吗？
        // 不会阻断 执行顺序过去了 
        //注意 ：执行顺序， 这种的  放在捕获进攻路线上也能拦不住 
        // 再次注意，先执行的是捕获后执行的是冒泡 
    -->
    <script>
        var father = document.getElementById('propagate'), child = father.children[0]; 
        // father 父元素 div元素 chid子元素 div中的p标签 

        father.addEventListener('click', function () {
            event.stopPropagation()
            console.log('event handler on father 父  div ');
        },false);  
        // 冒泡


        child.addEventListener('click', function () {
            console.log('event handler on child  子 p标签 ');
        },true);
        // 捕获 
    </script>

    <!-- 现在大多浏览器是冒泡 
        总结  
        执行顺序的不同和影响
        阻断的设置方法 
    
    -->

    <!-- 事件委托 例子 -->
    <script>
        document.querySelector('ul').addEventListener('click', function (e) {

        console.log(e.target.innerText)

            }, false)
            // target 哪个元素触发了点击事件 
            // ul元素添加点击事件 冒泡 ，其中li自动有点击事件 ，点击冒泡到ul，进行绑定？
    </script>


      
</body>
</html>